C# type-model sketch (interfaces / DTOs â€” descriptive, not runnable)

> Note: I use familiar C# naming but omit method bodies. Treat these as interface/DTO blueprints to implement.

### Core enums
```cs
enum Ternary { False = 0, Unknown = 1, True = 2 }
enum CertaintyLevel { Low, Medium, High, Confirmed }

```
### Fact representation
```cs
interface IFact
{
    Guid FactId { get; }
    Guid EntityId { get; }           // subject (person/case/object)
    string PredicateType { get; }    // unique token per domain (e.g., "RapeStatus")
    Enum Value { get; }              // typed enum value (domain specific) -- store as System.Enum
    Ternary TernaryState { get; }    // explicit tri-state (derived from Value mapping)
    CertaintyLevel Certainty { get; }
    DateTime Timestamp { get; }
    SourceDescriptor Source { get; } // who/what produced the fact
    Decoration Decoration { get; }  // free-text/contextual metadata
    IReadOnlyList<TraceId> Provenance { get; } // references to trace entries
}

```

`Decoration` = `{ string RawText; IDictionary<string,string> Tags; string Language; }`  
`SourceDescriptor` = `{ string SourceType; string SourceId; double ConfidenceScore; }`

### Rule representation
```cs
interface IRule
{
    Guid RuleId { get; }
    string Name { get; }                     // human label
    IList<IAntecedent> Antecedents { get; }  // AND-joined by default
    IList<IConsequent> Consequents { get; }  // assignments / transitions
    int CardinalPriority { get; }            // higher => fire earlier
    bool Defeasible { get; }                 // can be overridden
    ContextFilter ContextFilter { get; }     // when rule applies
    RuleMetadata Metadata { get; }           // author, version, doc
}

```

`IAntecedent`:
```cs
interface IAntecedent
{
    string PredicateType { get; }
    Enum ExpectedValue { get; }           // domain enum
    Ternary Accepts { get; }              // what ternary states will match (use mask)
    Func<EvalContext, EvalResult> Guard { get; } // optional guard function (facade)
}
```

`IConsequent`:
```cs
interface IConsequent
{
    string PredicateType { get; }
    Enum TargetValue { get; }
    CertaintyLevel CertaintyDelta { get; } // how it changes certainty
    bool IsDefeater { get; }               // negates/overrides target of another rule
    Action<EvalContext, IFact> SideEffect { get; } // optional side-effects (e.g., enqueue)
}

```
### EvalResult & Trace

```csharp
class EvalResult
{
    Ternary Result { get; }                     // False, Unknown, True
    double Score { get; }                       // plausibility/confidence numeric
    IReadOnlyList<TraceId> Steps { get; }       // contained trace ids for sub-evals
    string ShortCircuitReason { get; }          // if short-circuited
}

class TraceEntry
{
    Guid TraceId { get; }
    DateTime Timestamp { get; }
    Guid? RuleId { get; }                       // rule that caused this entry, if any
    string Operation { get; }                   // e.g., "EvaluateAntecedent", "ApplyConsequent"
    IReadOnlyList<FactSnapshot> InputFacts { get; }
    EvalResult EvalResult { get; }              // what the evaluation returned
    string KanbanTemplateId { get; }            // optional template reference
    string Message { get; }                     // human-friendly summary
}
```

`FactSnapshot` stores a shallow copy of the fact at time of eval (id/value/certainty/source).

### World & KB Deltas
```cs
class World
{
    Guid WorldId { get; }
    Guid ParentWorldId { get; }          // null for root
    IDictionary<Guid, IFact> Facts { get; }     // factId -> fact (world-local overrides)
    IList<TraceId> Trace { get; }        // ordered trace for this world
    IList<Conflict> Conflicts { get; }   // conflicts detected
    WorldState State { get; }            // Active, Frozen, Merged
}
```
### Conflict
```cs
class Conflict
{
    Guid ConflictId { get; }
    Guid FactId { get; }                 // base fact that conflicted
    IList<ConflictCandidate> Candidates { get; } // conflicting values / sources
    ConflictResolutionHint Hint { get; } // suggested resolution (auto or manual)
}
```