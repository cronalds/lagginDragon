Command-pattern for logical evaluation (concept)

Make every logical operation a `ICommand` (or `IEvaluationCommand`) so it:

- contains inputs (references to facts or sub-commands),
- executes deterministically given an `EvalContext`,
- returns `EvalResult`,
- appends a `TraceEntry` to the executing world.

Key command types:

- `PredicateEvalCommand` — compare `IFact` to expected enum value; returns `Ternary` & provenance.
- `ConjunctionCommand` — list of sub-commands; stops at first `False` per short-circuit; if `Unknown` encountered and `unknown-as-possible` is set, note but continue based on config.
- `DisjunctionCommand` — stops at first `True` (or `Unknown` when allowed).
- `NotCommand` — negates child `Ternary` (map: True→False, False→True, Unknown→Unknown).
- `RuleEvalCommand` — wraps antecedent evaluation + consequence application.

Important: each command MUST accept an `EvalContext` that includes:

- `WorldId`
- `ActivePriorities`
- `TraceCollector` (append-only)
- `ShortCircuitingPolicy` (how to treat unknowns)
- `SecurityContext` (RBAC)

Each command, on execute:

1. snapshot input facts (for provenance)
2. run sub-evals (child commands)
3. create `TraceEntry` for this command with short-circuit info
4. return `EvalResult`

Because commands are objects, you can serialize them, replay them, persist them into the trace ledger, and reconstruct exact execution later.
